/**
 * Auto-generated typed API client for Bunbox
 * Do not edit this file manually
 */

import type * as Route0 from "../app/api/examples/route.ts";
import type * as Route1 from "../app/api/health/route.ts";
import type * as Route2 from "../app/api/stream/route.ts";
import type * as Route3 from "../app/api/users/route.ts";

// Response types extracted from handlers
type Route0_createExample_Params = typeof Route0.createExample extends { __types: { params: infer T } } ? T : Record<string, unknown>;
type Route0_createExample_Query = typeof Route0.createExample extends { __types: { query: infer T } } ? T : Record<string, unknown>;
type Route0_createExample_Body = typeof Route0.createExample extends { __types: { body: infer T } } ? T : unknown;
type Route0_createExample_Response = typeof Route0.createExample extends { __types: { response: infer T } } ? T : Awaited<ReturnType<typeof Route0.createExample>>;
type Route0_getExamples_Params = typeof Route0.getExamples extends { __types: { params: infer T } } ? T : Record<string, unknown>;
type Route0_getExamples_Query = typeof Route0.getExamples extends { __types: { query: infer T } } ? T : Record<string, unknown>;
type Route0_getExamples_Body = typeof Route0.getExamples extends { __types: { body: infer T } } ? T : unknown;
type Route0_getExamples_Response = typeof Route0.getExamples extends { __types: { response: infer T } } ? T : Awaited<ReturnType<typeof Route0.getExamples>>;
type Route0_updateExample_Params = typeof Route0.updateExample extends { __types: { params: infer T } } ? T : Record<string, unknown>;
type Route0_updateExample_Query = typeof Route0.updateExample extends { __types: { query: infer T } } ? T : Record<string, unknown>;
type Route0_updateExample_Body = typeof Route0.updateExample extends { __types: { body: infer T } } ? T : unknown;
type Route0_updateExample_Response = typeof Route0.updateExample extends { __types: { response: infer T } } ? T : Awaited<ReturnType<typeof Route0.updateExample>>;
type Route1_healthCheck_Params = typeof Route1.healthCheck extends { __types: { params: infer T } } ? T : Record<string, unknown>;
type Route1_healthCheck_Query = typeof Route1.healthCheck extends { __types: { query: infer T } } ? T : Record<string, unknown>;
type Route1_healthCheck_Body = typeof Route1.healthCheck extends { __types: { body: infer T } } ? T : unknown;
type Route1_healthCheck_Response = typeof Route1.healthCheck extends { __types: { response: infer T } } ? T : Awaited<ReturnType<typeof Route1.healthCheck>>;
type Route2_streamTokens_Params = typeof Route2.streamTokens extends { __types: { params: infer T } } ? T : Record<string, unknown>;
type Route2_streamTokens_Query = typeof Route2.streamTokens extends { __types: { query: infer T } } ? T : Record<string, unknown>;
type Route2_streamTokens_Body = typeof Route2.streamTokens extends { __types: { body: infer T } } ? T : unknown;
type Route2_streamTokens_Response = typeof Route2.streamTokens extends { __types: { response: infer T } } ? T : Awaited<ReturnType<typeof Route2.streamTokens>>;
type Route3_createUser_Params = typeof Route3.createUser extends { __types: { params: infer T } } ? T : Record<string, unknown>;
type Route3_createUser_Query = typeof Route3.createUser extends { __types: { query: infer T } } ? T : Record<string, unknown>;
type Route3_createUser_Body = typeof Route3.createUser extends { __types: { body: infer T } } ? T : unknown;
type Route3_createUser_Response = typeof Route3.createUser extends { __types: { response: infer T } } ? T : Awaited<ReturnType<typeof Route3.createUser>>;
type Route3_listUsers_Params = typeof Route3.listUsers extends { __types: { params: infer T } } ? T : Record<string, unknown>;
type Route3_listUsers_Query = typeof Route3.listUsers extends { __types: { query: infer T } } ? T : Record<string, unknown>;
type Route3_listUsers_Body = typeof Route3.listUsers extends { __types: { body: infer T } } ? T : unknown;
type Route3_listUsers_Response = typeof Route3.listUsers extends { __types: { response: infer T } } ? T : Awaited<ReturnType<typeof Route3.listUsers>>;

import { createQueryHook } from "/Users/anthonydemattos/bunbox/packages/bunbox/src/client/useQuery";
import type { UseQueryOptions, UseQueryResult } from "/Users/anthonydemattos/bunbox/packages/bunbox/src/client/useQuery";
import { useStream as useStreamHook } from "/Users/anthonydemattos/bunbox/packages/bunbox/src/client/useStream";
import type { UseStreamOptions, UseStreamResult } from "/Users/anthonydemattos/bunbox/packages/bunbox/src/client/useStream";

async function* parseResponseStream(res: Response, transform: (chunk: string) => any): AsyncGenerator<any> {
  const reader = res.body?.getReader();
  if (!reader) return;
  const decoder = new TextDecoder();
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    const chunk = decoder.decode(value, { stream: true });
    yield* transform(chunk);
  }
}

function* parseSSEChunk(chunk: string): Generator<any> {
  const lines = chunk.split("\n\n");
  for (const line of lines) {
    if (line.startsWith("data: ")) {
      try { yield JSON.parse(line.slice(6)); } catch {}
    }
  }
}

async function* parseSSE(res: Response): AsyncGenerator<any> {
  return yield* parseResponseStream(res, parseSSEChunk);
}

async function* parseStream(res: Response): AsyncGenerator<any> {
  return yield* parseResponseStream(res, function* (chunk) { yield chunk; });
}

type ClientResponse<T> = T extends { __brand: 'streaming', __type: infer U }
  ? AsyncIterable<U>
  : T extends { __brand: 'sse', __type: infer U }
  ? AsyncIterable<U>
  : T;

async function request<TResponse, TParams = Record<string, unknown>, TQuery = Record<string, unknown>, TBody = unknown>(
  method: string,
  path: string,
  opts?: { params?: TParams; query?: TQuery; body?: TBody; headers?: HeadersInit }
): Promise<ClientResponse<TResponse>> {
  let url = path;
  if (opts?.params) {
    for (const [k, v] of Object.entries(opts.params)) url = url.replace(`[${k}]`, String(v));
  }
  if (opts?.query) {
    const p = new URLSearchParams();
    for (const [k, v] of Object.entries(opts.query)) p.append(k, String(v));
    url += `?${p}`;
  }
  if (url.startsWith("/") && typeof window === "undefined") {
    url = `http://${process.env.BUNBOX_HOSTNAME || "localhost" }:${process.env.BUNBOX_PORT || "3000"}${url}`;
  }
  const res = await fetch(url, {
    method,
    headers: { "Content-Type": "application/json", ...opts?.headers },
    body: opts?.body && method !== "GET" ? JSON.stringify(opts.body) : undefined,
  });
  if (!res.ok) throw new Error(await res.text());
  const contentType = res.headers.get('content-type') || '';
  if (contentType.includes('text/event-stream')) {
    return parseSSE(res) as any;
  }
  if (res.headers.has('X-Bunbox-Stream')) {
    return parseStream(res) as any;
  }
  return res.json();
}

// Flattened options type - params, query, and body all at top level
// Exclude default Record<string, unknown> to avoid index signature conflicts
type IsDefaultRecord<T> = T extends Record<string, unknown>
  ? keyof T extends never ? true : string extends keyof T ? true : false
  : false;
type FlattenedOptions<TParams, TQuery, TBody> = 
  & (IsDefaultRecord<TParams> extends true ? {} : TParams)
  & (IsDefaultRecord<TQuery> extends true ? {} : TQuery)
  & (IsDefaultRecord<TBody> extends true ? {} : TBody)
  & { headers?: HeadersInit };

type ApiMethod<TResponse, TParams, TQuery, TBody> = {
  (opts?: FlattenedOptions<TParams, TQuery, TBody>): Promise<ClientResponse<TResponse>>;
  useQuery: (opts?: FlattenedOptions<TParams, TQuery, TBody> & { enabled?: boolean }) => UseQueryResult<ClientResponse<TResponse>>;
  useStream: (opts?: FlattenedOptions<TParams, TQuery, TBody> & { enabled?: boolean; onMessage?: (data: any) => void; onError?: (error: Error) => void; onFinish?: () => void }) => UseStreamResult<TResponse extends { __type: infer U } ? U : TResponse>;
};

function createApiMethod<TResponse, TParams = Record<string, unknown>, TQuery = Record<string, unknown>, TBody = unknown>(
  method: string,
  path: string,
  paramKeys: string[]
): ApiMethod<TResponse, TParams, TQuery, TBody> {
  // Separate flattened options into params/query/body based on method and paramKeys
  function separateOptions(opts?: Record<string, unknown>) {
    if (!opts) return {};
    const params: Record<string, unknown> = {};
    const query: Record<string, unknown> = {};
    const body: Record<string, unknown> = {};
    const headers = opts.headers as HeadersInit | undefined;
    const enabled = opts.enabled;
    
    for (const [key, value] of Object.entries(opts)) {
      if (key === 'headers' || key === 'enabled' || key === 'onMessage' || key === 'onError' || key === 'onFinish') continue;
      if (paramKeys.includes(key)) {
        params[key] = value;
      } else if (method === 'GET' || method === 'DELETE') {
        query[key] = value;
      } else {
        body[key] = value;
      }
    }
    return { params, query, body, headers, enabled };
  }
  
  const fn = (opts?: FlattenedOptions<TParams, TQuery, TBody>) => {
    const { params, query, body, headers } = separateOptions(opts as Record<string, unknown>);
    return request<TResponse, TParams, TQuery, TBody>(method, path, { params: params as TParams, query: query as TQuery, body: body as TBody, headers });
  };
  fn.useQuery = (opts?: FlattenedOptions<TParams, TQuery, TBody> & { enabled?: boolean }) => {
    const separated = separateOptions(opts as Record<string, unknown>);
    return createQueryHook<ClientResponse<TResponse>>(method, path, { params: separated.params, query: separated.query, body: separated.body, headers: separated.headers, enabled: separated.enabled as boolean | undefined });
  };
  fn.useStream = (opts?: FlattenedOptions<TParams, TQuery, TBody> & { enabled?: boolean; onMessage?: (data: any) => void; onError?: (error: Error) => void; onFinish?: () => void }) => {
    type ExtractedType = TResponse extends { __type: infer U } ? U : TResponse;
    return useStreamHook<ExtractedType>(fn, opts);
  };
  return fn as ApiMethod<TResponse, TParams, TQuery, TBody>;
}

export const api = {
  examples: {
    createExample: createApiMethod<Route0_createExample_Response, Route0_createExample_Params, Route0_createExample_Query, Route0_createExample_Body>("POST", "/api/examples", []),
    getExamples: createApiMethod<Route0_getExamples_Response, Route0_getExamples_Params, Route0_getExamples_Query, Route0_getExamples_Body>("GET", "/api/examples", []),
    updateExample: createApiMethod<Route0_updateExample_Response, Route0_updateExample_Params, Route0_updateExample_Query, Route0_updateExample_Body>("PUT", "/api/examples", [])
  },
  health: {
    healthCheck: createApiMethod<Route1_healthCheck_Response, Route1_healthCheck_Params, Route1_healthCheck_Query, Route1_healthCheck_Body>("GET", "/api/health", [])
  },
  stream: {
    streamTokens: createApiMethod<Route2_streamTokens_Response, Route2_streamTokens_Params, Route2_streamTokens_Query, Route2_streamTokens_Body>("GET", "/api/stream", [])
  },
  users: {
    createUser: createApiMethod<Route3_createUser_Response, Route3_createUser_Params, Route3_createUser_Query, Route3_createUser_Body>("POST", "/api/users", []),
    listUsers: createApiMethod<Route3_listUsers_Response, Route3_listUsers_Params, Route3_listUsers_Query, Route3_listUsers_Body>("GET", "/api/users", [])
  }
};