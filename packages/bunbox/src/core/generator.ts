/**
 * Route generator for Bunbox
 * Generates routes.ts and api-client.ts files
 */

import { join } from "path";
import { mkdir } from "node:fs/promises";
import { scanPageRoutes, scanLayouts, scanApiRoutes } from "./scanner";
import { routePathToUrl, toBunRoutePath } from "./router";
import { checkUseServer } from "./ssr";
import { dynamicImport, resolveAbsolutePath, getBunboxDir } from "./utils";
import type { ApiRouteModule } from "./types";

/**
 * Generate routes file for client-side hydration
 */
export async function generateRoutesFile(appDir: string): Promise<string> {
  const pageRoutes = await scanPageRoutes(appDir);
  const layouts = await scanLayouts(appDir);

  const imports: string[] = [];
  const routeExports: string[] = [];
  const layoutExports: string[] = [];
  const ssrPages: string[] = [];

  let importCounter = 0;

  // Generate page imports and detect SSR pages
  for (const route of pageRoutes) {
    const importName = `Page${importCounter++}`;
    const routePath = routePathToUrl(route.filepath);

    imports.push(`import ${importName} from "../app/${route.filepath}";`);
    routeExports.push(`  "${routePath}": ${importName}`);

    // Check if this page has "use server"
    const pagePath = join(appDir, route.filepath);
    if (await checkUseServer(pagePath)) {
      ssrPages.push(`  "${routePath}"`);
    }
  }

  // Generate layout imports
  for (const [routePath, layoutFile] of layouts.entries()) {
    const importName = `Layout${importCounter++}`;
    imports.push(`import ${importName} from "../app/${layoutFile}";`);
    layoutExports.push(`  "${routePath}": ${importName}`);
  }

  // Write routes file
  const bunboxDir = getBunboxDir();
  await mkdir(bunboxDir, { recursive: true });

  const routesContent = `/**
 * Auto-generated routes file for Bunbox
 * Do not edit this file manually
 */

${imports.join("\n")}

export const routes = {
${routeExports.join(",\n")}
};

export const layouts = {
${layoutExports.join(",\n")}
};

// Set of route paths that require server-side rendering
export const ssrPages = new Set([
${ssrPages.join(",\n")}
]);
`;

  await Bun.write(join(bunboxDir, "routes.ts"), routesContent);

  // Create entry point
  const hydratePath = join(import.meta.dir, "..", "client", "hydrate.tsx");
  const entryContent = `/**
 * Auto-generated entry point for Bunbox client
 * Do not edit this file manually
 */

import { initBunbox } from "${hydratePath}";
import { routes, layouts, ssrPages } from "./routes";

// Initialize the app
initBunbox(routes, layouts, ssrPages).catch((error) => {
  console.error("Failed to initialize Bunbox app:", error);
});
`;

  const entryPath = join(bunboxDir, "entry.ts");
  await Bun.write(entryPath, entryContent);

  return entryPath;
}

/**
 * Generate typed API client for all API routes
 */
export async function generateApiClient(appDir: string): Promise<void> {
  const apiRoutes = await scanApiRoutes(appDir);
  const bunboxDir = getBunboxDir();
  await mkdir(bunboxDir, { recursive: true });

  const HTTP_METHODS = ["GET", "POST", "PUT", "DELETE", "PATCH"] as const;

  // Scan routes and build client structure
  const routeTree: Record<string, any> = {};
  const typeImports: string[] = [];
  let importCounter = 0;

  for (const route of apiRoutes) {
    try {
      const absolutePath = resolveAbsolutePath(join(appDir, route.filepath));
      const module = await dynamicImport<ApiRouteModule>(absolutePath, false);
      const availableMethods = HTTP_METHODS.filter((method) => module[method]);

      if (availableMethods.length === 0) continue;

      // Get clean paths
      const routePath = toBunRoutePath(route);
      const clientPath = routePath.replace(/^\/api\/?/, "") || "/";
      const urlPath = routePath.replace(/:([^/]+)/g, "[$1]");
      const segments = clientPath.split("/").filter(Boolean);

      // Build nested tree structure
      let current: any = routeTree;
      const lastIndex = segments.length - 1;

      for (let i = 0; i <= lastIndex; i++) {
        const key = segments[i];
        if (!key) continue;

        if (i === lastIndex) {
          // Add methods at leaf node
          if (!current[key]) current[key] = {};
          const importName = `Route${importCounter++}`;
          typeImports.push(
            `import type * as ${importName} from "../app/${route.filepath}";`
          );

          for (const method of availableMethods) {
            current[key][method] = {
              path: urlPath,
              importName,
              method,
              typeAlias: `${importName}_${method}`,
            };
          }
        } else {
          // Navigate/create intermediate nodes
          current = current[key] = current[key] || {};
        }
      }
    } catch (error) {
      console.warn(`Could not analyze API route: ${route.filepath}`);
    }
  }

  // Generate client code
  const clientCode = generateClientCode(routeTree, typeImports);
  await Bun.write(join(bunboxDir, "api-client.ts"), clientCode);
}

/**
 * Generate the actual client code from route tree
 */
function generateClientCode(
  routeTree: Record<string, any>,
  typeImports: string[]
): string {
  const lines: string[] = [
    "/**",
    " * Auto-generated typed API client for Bunbox",
    " * Do not edit this file manually",
    " */",
    "",
  ];

  // Add type imports
  if (typeImports.length > 0) {
    lines.push(...typeImports, "");
  }

  // Add Infer utility from bunbox
  lines.push("import type { Infer } from '@ademattos/bunbox';", "");

  // Generate type aliases for each route method
  const { internalTypes, exportedTypes } = generateTypeAliases(routeTree);
  if (internalTypes.length > 0) {
    lines.push("// Internal route type definitions", ...internalTypes, "");
  }
  if (exportedTypes.length > 0) {
    lines.push("// Exported response types", ...exportedTypes, "");
  }

  lines.push(
    "// Request options interface",
    "interface RequestOptions<TParams = any, TQuery = any, TBody = any> {",
    "  params?: TParams;",
    "  query?: TQuery;",
    "  body?: TBody;",
    "  headers?: HeadersInit;",
    "}",
    ""
  );

  // Add makeRequest function
  lines.push(
    "async function request<T = any>(",
    "  method: string,",
    "  path: string,",
    "  options?: RequestOptions",
    "): Promise<T> {",
    "  let url = path;",
    "",
    "  if (options?.params) {",
    "    for (const [key, value] of Object.entries(options.params)) {",
    "      url = url.replace(`[${key}]`, String(value));",
    "    }",
    "  }",
    "",
    "  if (options?.query) {",
    "    const params = new URLSearchParams();",
    "    for (const [key, value] of Object.entries(options.query)) {",
    "      params.append(key, String(value));",
    "    }",
    "    url += `?${params.toString()}`;",
    "  }",
    "",
    "  const init: RequestInit = {",
    "    method,",
    "    headers: {",
    '      "Content-Type": "application/json",',
    "      ...options?.headers,",
    "    },",
    "  };",
    "",
    '  if (options?.body && method !== "GET") {',
    "    init.body = JSON.stringify(options.body);",
    "  }",
    "",
    "  const response = await fetch(url, init);",
    "",
    "  if (!response.ok) {",
    '    const error = await response.json().catch(() => ({ error: "Request failed" }));',
    "    throw new Error(error.error || `HTTP ${response.status}`);",
    "  }",
    "",
    "  return response.json();",
    "}",
    ""
  );

  // Build API object
  lines.push("export const api = {");
  lines.push(...buildApiObject(routeTree, 1));
  lines.push("};");

  return lines.join("\n");
}

/**
 * Generate a single type alias for a field
 */
function createTypeAlias(
  typeAlias: string,
  field: string,
  importName: string,
  method: string,
  defaultType: string
): string {
  const fieldCap = field.charAt(0).toUpperCase() + field.slice(1);
  return `type ${typeAlias}_${fieldCap} = typeof ${importName}.${method} extends { __definition?: { ${field}?: infer T } } ? T extends { validate: any } ? Infer<T> : ${defaultType} : ${defaultType};`;
}

/**
 * Convert route path to clean type name
 */
function routeToTypeName(path: string, method: string): string {
  // Convert /api/users/[id] GET -> UsersIdGet
  const cleaned = path
    .replace(/^\/api\/?/, "")
    .replace(/\[(\w+)\]/g, "$1") // [id] -> id
    .split("/")
    .filter(Boolean)
    .map((s) => s.charAt(0).toUpperCase() + s.slice(1))
    .join("");

  const methodCap = method.charAt(0) + method.slice(1).toLowerCase();
  return cleaned ? `${cleaned}${methodCap}` : methodCap;
}

/**
 * Generate type aliases for route methods
 */
function generateTypeAliases(node: Record<string, any>): {
  internalTypes: string[];
  exportedTypes: string[];
} {
  const internalTypes: string[] = [];
  const exportedTypes: string[] = [];
  const defaults = {
    params: "Record<string, string>",
    query: "Record<string, string>",
    body: "any",
    response: "any",
  };

  function traverse(obj: Record<string, any>) {
    for (const value of Object.values(obj)) {
      if (value.path && value.method && value.typeAlias) {
        const { typeAlias, importName, method, path } = value;

        // Generate internal types for all fields
        for (const [field, defaultType] of Object.entries(defaults)) {
          internalTypes.push(
            createTypeAlias(typeAlias, field, importName, method, defaultType)
          );
        }

        // Generate clean exported types
        const exportName = routeToTypeName(path, method);
        exportedTypes.push(
          `export type ${exportName}Response = ${typeAlias}_Response;`,
          `export type ${exportName}Params = ${typeAlias}_Params;`,
          `export type ${exportName}Body = ${typeAlias}_Body;`
        );
      } else if (typeof value === "object") {
        traverse(value);
      }
    }
  }

  traverse(node);
  return { internalTypes, exportedTypes };
}

/**
 * Recursively build the API object structure
 */
function buildApiObject(node: Record<string, any>, indent: number): string[] {
  const lines: string[] = [];
  const indentStr = "  ".repeat(indent);
  const entries = Object.entries(node);

  entries.forEach(([key, value], i) => {
    const comma = i < entries.length - 1 ? "," : "";

    if (value.path && value.method) {
      // Method definition
      const { path, method, typeAlias } = value;
      lines.push(
        `${indentStr}${method}: (opts?: RequestOptions<${typeAlias}_Params, ${typeAlias}_Query, ${typeAlias}_Body>) => request<${typeAlias}_Response>("${method}", "${path}", opts)${comma}`
      );
    } else {
      // Nested object
      const quotedKey = /^:|[^a-zA-Z0-9_$]/.test(key) ? `"${key}"` : key;
      lines.push(
        `${indentStr}${quotedKey}: {`,
        ...buildApiObject(value, indent + 1),
        `${indentStr}}${comma}`
      );
    }
  });

  return lines;
}
