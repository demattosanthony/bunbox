/**
 * Route generator for Bunbox
 * Generates routes.ts and api-client.ts files
 */

import { join } from "path";
import { mkdir } from "node:fs/promises";
import { scanPageRoutes, scanLayouts, scanApiRoutes } from "./scanner";
import { routePathToUrl, toBunRoutePath } from "./router";
import { checkUseServer } from "./ssr";
import { dynamicImport, resolveAbsolutePath } from "./utils";
import {
  buildApiObject,
  generateTypeAliases,
  HTTP_METHODS,
} from "./generator/type-helpers";
import type {
  ApiRouteTreeNode,
  ApiRouteMethodMeta,
} from "./generator/type-helpers";
import type { ApiRouteModule } from "./types";
import type { ResolvedBunboxConfig } from "./config";

function createRouteTreeNode(): ApiRouteTreeNode {
  return {
    children: new Map(),
    methods: [],
  };
}

function insertRouteMethod(
  node: ApiRouteTreeNode,
  segments: string[],
  meta: ApiRouteMethodMeta
): void {
  let current = node;

  for (const segment of segments) {
    if (!current.children.has(segment)) {
      current.children.set(segment, createRouteTreeNode());
    }
    current = current.children.get(segment)!;
  }

  current.methods.push(meta);
}

/**
 * Generate routes file for client-side hydration
 */
export async function generateRoutesFile(appDir: string): Promise<string> {
  const pageRoutes = (await scanPageRoutes(appDir)).sort((a, b) =>
    a.filepath.localeCompare(b.filepath)
  );
  const layouts = await scanLayouts(appDir);

  const imports: string[] = [];
  const routeExports: string[] = [];
  const layoutExports: string[] = [];
  const ssrPages: string[] = [];

  const pageEntries = await Promise.all(
    pageRoutes.map(async (route, index) => {
      const routePath = routePathToUrl(route.filepath);
      const importName = `Page${index}`;
      const requiresSSR = await checkUseServer(join(appDir, route.filepath));

      return {
        importName,
        routePath,
        filepath: route.filepath,
        requiresSSR,
      };
    })
  );

  for (const entry of pageEntries) {
    imports.push(`import ${entry.importName} from "../app/${entry.filepath}";`);
    routeExports.push(`  "${entry.routePath}": ${entry.importName}`);
    if (entry.requiresSSR) {
      ssrPages.push(`  "${entry.routePath}"`);
    }
  }

  const sortedLayouts = Array.from(layouts.entries()).sort(([a], [b]) =>
    a.localeCompare(b)
  );

  let layoutCounter = pageEntries.length;
  for (const [routePath, layoutFile] of sortedLayouts) {
    const importName = `Layout${layoutCounter++}`;
    imports.push(`import ${importName} from "../app/${layoutFile}";`);
    layoutExports.push(`  "${routePath}": ${importName}`);
  }

  // Write routes file
  const bunboxDir = join(process.cwd(), ".bunbox");
  await mkdir(bunboxDir, { recursive: true });

  const routesContent = `/**
 * Auto-generated routes file for Bunbox
 * Do not edit this file manually
 */

${imports.join("\n")}

export const routes = {
${routeExports.join(",\n")}
};

export const layouts = {
${layoutExports.join(",\n")}
};

// Set of route paths that require server-side rendering
export const ssrPages = new Set([
${ssrPages.join(",\n")}
]);
`;

  await Bun.write(join(bunboxDir, "routes.ts"), routesContent);

  // Create entry point
  const hydratePath = join(import.meta.dir, "..", "client", "hydrate.tsx");
  const entryContent = `/**
 * Auto-generated entry point for Bunbox client
 * Do not edit this file manually
 */

import { initBunbox } from "${hydratePath}";
import { routes, layouts, ssrPages } from "./routes";

// Initialize the app
initBunbox(routes, layouts, ssrPages).catch((error) => {
  console.error("Failed to initialize Bunbox app:", error);
});
`;

  const entryPath = join(bunboxDir, "entry.ts");
  await Bun.write(entryPath, entryContent);

  return entryPath;
}

/**
 * Generate typed API client for all API routes
 */
export async function generateApiClient(
  appDir: string,
  config?: ResolvedBunboxConfig
): Promise<void> {
  const apiRoutes = (await scanApiRoutes(appDir)).sort((a, b) =>
    a.filepath.localeCompare(b.filepath)
  );
  const bunboxDir = join(process.cwd(), ".bunbox");
  await mkdir(bunboxDir, { recursive: true });

  // Scan routes and build client structure
  const routeTree = createRouteTreeNode();
  const typeImports: string[] = [];
  let importCounter = 0;

  for (const route of apiRoutes) {
    try {
      const absolutePath = resolveAbsolutePath(join(appDir, route.filepath));
      const module = await dynamicImport<ApiRouteModule>(absolutePath, false);
      const availableMethods = HTTP_METHODS.filter((method) => module[method]);

      if (availableMethods.length === 0) continue;

      // Get clean paths
      const routePath = toBunRoutePath(route);
      const clientPath = routePath.replace(/^\/api\/?/, "") || "/";
      const urlPath = routePath.replace(/:([^/]+)/g, "[$1]");
      const segments =
        clientPath === "/" ? [] : clientPath.split("/").filter(Boolean);

      const importName = `Route${importCounter++}`;
      typeImports.push(
        `import type * as ${importName} from "../app/${route.filepath}";`
      );

      for (const method of availableMethods) {
        insertRouteMethod(routeTree, segments, {
          path: urlPath,
          importName,
          method,
          typeAlias: `${importName}_${method}`,
        });
      }
    } catch (error) {
      console.warn(`Could not analyze API route: ${route.filepath}`);
    }
  }

  // Generate client code
  const clientCode = generateClientCode(routeTree, typeImports, config);
  await Bun.write(join(bunboxDir, "api-client.ts"), clientCode);
}

/**
 * Generate the actual client code from route tree
 */
function generateClientCode(
  routeTree: ApiRouteTreeNode,
  typeImports: string[],
  config?: ResolvedBunboxConfig
): string {
  const lines: string[] = [
    "/**",
    " * Auto-generated typed API client for Bunbox",
    " * Do not edit this file manually",
    " */",
    "",
  ];

  // Add type imports
  if (typeImports.length > 0) {
    lines.push(...typeImports, "");
  }

  // Generate type aliases
  const typeAliases = generateTypeAliases(routeTree);
  if (typeAliases.length > 0) {
    lines.push("// Response types extracted from handlers", ...typeAliases, "");
  }

  // Add request function
  lines.push(
    "async function request<T>(method: string, path: string, opts?: any): Promise<T> {",
    "  let url = path;",
    "  if (opts?.params) {",
    "    for (const [k, v] of Object.entries(opts.params)) url = url.replace(`[${k}]`, String(v));",
    "  }",
    "  if (opts?.query) {",
    "    const p = new URLSearchParams();",
    "    for (const [k, v] of Object.entries(opts.query)) p.append(k, String(v));",
    "    url += `?${p}`;",
    "  }",
    '  if (url.startsWith("/") && typeof window === "undefined") {',
    `    url = \`http://\${process.env.BUNBOX_HOSTNAME || "${
      config?.hostname || "localhost"
    }"\ }:\${process.env.BUNBOX_PORT || "${config?.port || 3000}"}\${url}\`;`,
    "  }",
    "  const res = await fetch(url, {",
    "    method,",
    '    headers: { "Content-Type": "application/json", ...opts?.headers },',
    '    body: opts?.body && method !== "GET" ? JSON.stringify(opts.body) : undefined,',
    "  });",
    "  if (!res.ok) throw new Error(await res.text());",
    "  return res.json();",
    "}",
    ""
  );

  // Build API object
  lines.push("export const api = {");
  const apiLines = buildApiObject(routeTree, 1);
  if (apiLines.length > 0) {
    lines.push(...apiLines);
  }
  lines.push("};");

  return lines.join("\n");
}
