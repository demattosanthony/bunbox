/**
 * Route generator for Bunbox
 * Generates routes.ts and api-client.ts files
 */

import { join } from "path";
import { mkdir } from "node:fs/promises";
import { scanPageRoutes, scanLayouts, scanApiRoutes } from "./scanner";
import { routePathToUrl, toBunRoutePath } from "./router";
import { dynamicImport, resolveAbsolutePath } from "./utils";
import {
  buildApiObject,
  generateTypeAliases,
} from "./generator/type-helpers";
import type {
  ApiRouteTreeNode,
  ApiRouteMethodMeta,
} from "./generator/type-helpers";
import type { ResolvedBunboxConfig } from "./config";

/**
 * Extract handlers with __method from a route module
 * Returns array of [exportName, method] pairs
 */
function extractMethodHandlers(
  module: Record<string, unknown>
): Array<{ exportName: string; method: string }> {
  const handlers: Array<{ exportName: string; method: string }> = [];

  for (const [exportName, value] of Object.entries(module)) {
    if (
      typeof value === "function" &&
      "__method" in value &&
      typeof (value as { __method: unknown }).__method === "string"
    ) {
      handlers.push({
        exportName,
        method: (value as { __method: string }).__method,
      });
    }
  }

  return handlers;
}

function createRouteTreeNode(): ApiRouteTreeNode {
  return {
    children: new Map(),
    methods: [],
  };
}

function insertRouteMethod(
  node: ApiRouteTreeNode,
  segments: string[],
  meta: ApiRouteMethodMeta
): void {
  let current = node;

  // Only traverse static segments, skip dynamic ones (starting with ":")
  // This flattens routes like /users/:id to just /users with the handler attached
  for (const segment of segments) {
    if (segment.startsWith(":")) continue;
    if (!current.children.has(segment)) {
      current.children.set(segment, createRouteTreeNode());
    }
    current = current.children.get(segment)!;
  }

  current.methods.push(meta);
}

/**
 * Generate routes file for client-side hydration
 * All pages are included in the client bundle for full hydration
 */
export async function generateRoutesFile(appDir: string): Promise<string> {
  const pageRoutes = (await scanPageRoutes(appDir)).sort((a, b) =>
    a.filepath.localeCompare(b.filepath)
  );
  const layouts = await scanLayouts(appDir);

  const imports: string[] = [];
  const routeExports: string[] = [];
  const layoutExports: string[] = [];

  // Build page entries
  const pageEntries = pageRoutes.map((route, index) => {
    const routePath = routePathToUrl(route.filepath);
    const importName = `Page${index}`;
    return { importName, routePath, filepath: route.filepath };
  });

  // Import ALL pages into client bundle
  for (const entry of pageEntries) {
    imports.push(
      `import ${entry.importName} from "../app/${entry.filepath}";`
    );
    routeExports.push(`  "${entry.routePath}": ${entry.importName}`);
  }

  // Import ALL layouts into client bundle (needed for client pages)
  const sortedLayouts = Array.from(layouts.entries()).sort(([a], [b]) =>
    a.localeCompare(b)
  );

  let layoutCounter = pageEntries.length;
  for (const [routePath, layoutFile] of sortedLayouts) {
    const importName = `Layout${layoutCounter++}`;
    imports.push(`import ${importName} from "../app/${layoutFile}";`);
    layoutExports.push(`  "${routePath}": ${importName}`);
  }

  // Write routes file
  const bunboxDir = join(process.cwd(), ".bunbox");
  await mkdir(bunboxDir, { recursive: true });

  const routesContent = `/**
 * Auto-generated routes file for Bunbox
 * Do not edit this file manually
 */

${imports.join("\n")}

export const routes = {
${routeExports.join(",\n")}
};

export const layouts = {
${layoutExports.join(",\n")}
};
`;

  await Bun.write(join(bunboxDir, "routes.ts"), routesContent);

  // Create entry point
  const hydratePath = join(import.meta.dir, "..", "client", "hydrate.tsx");
  const entryContent = `/**
 * Auto-generated entry point for Bunbox client
 * Do not edit this file manually
 */

import { initBunbox } from "${hydratePath}";
import { routes, layouts } from "./routes";

// Initialize the app
initBunbox(routes, layouts).catch((error) => {
  console.error("Failed to initialize Bunbox app:", error);
});
`;

  const entryPath = join(bunboxDir, "entry.ts");
  await Bun.write(entryPath, entryContent);

  return entryPath;
}

/**
 * Generate typed API client for all API routes
 */
export async function generateApiClient(
  appDir: string,
  config?: ResolvedBunboxConfig
): Promise<void> {
  const apiRoutes = (await scanApiRoutes(appDir)).sort((a, b) =>
    a.filepath.localeCompare(b.filepath)
  );
  const bunboxDir = join(process.cwd(), ".bunbox");
  await mkdir(bunboxDir, { recursive: true });

  // Scan routes and build client structure
  const routeTree = createRouteTreeNode();
  const typeImports: string[] = [];
  let importCounter = 0;

  for (const route of apiRoutes) {
    try {
      const absolutePath = resolveAbsolutePath(join(appDir, route.filepath));
      const module = await dynamicImport<Record<string, unknown>>(
        absolutePath,
        false
      );
      const handlers = extractMethodHandlers(module);

      if (handlers.length === 0) continue;

      // Get clean paths
      const routePath = toBunRoutePath(route);
      const clientPath = routePath.replace(/^\/api\/?/, "") || "/";
      const urlPath = routePath.replace(/:([^/]+)/g, "[$1]");
      const segments =
        clientPath === "/" ? [] : clientPath.split("/").filter(Boolean);

      const importName = `Route${importCounter++}`;
      typeImports.push(
        `import type * as ${importName} from "../app/${route.filepath}";`
      );

      for (const { exportName, method } of handlers) {
        insertRouteMethod(routeTree, segments, {
          path: urlPath,
          importName,
          exportName,
          method,
          typeAlias: `${importName}_${exportName}`,
        });
      }
    } catch (error) {
      console.warn(`Could not analyze API route: ${route.filepath}`);
    }
  }

  // Generate client code
  const clientCode = generateClientCode(routeTree, typeImports, config);
  await Bun.write(join(bunboxDir, "api-client.ts"), clientCode);
}

/**
 * Generate the actual client code from route tree
 */
function generateClientCode(
  routeTree: ApiRouteTreeNode,
  typeImports: string[],
  config?: ResolvedBunboxConfig
): string {
  const lines: string[] = [
    "/**",
    " * Auto-generated typed API client for Bunbox",
    " * Do not edit this file manually",
    " */",
    "",
  ];

  // Add type imports
  if (typeImports.length > 0) {
    lines.push(...typeImports, "");
  }

  // Generate type aliases
  const typeAliases = generateTypeAliases(routeTree);
  if (typeAliases.length > 0) {
    lines.push("// Response types extracted from handlers", ...typeAliases, "");
  }

  // Import React hooks
  const useQueryPath = join(import.meta.dir, "..", "client", "useQuery");
  const useStreamPath = join(import.meta.dir, "..", "client", "useStream");
  lines.push(
    `import { createQueryHook } from "${useQueryPath}";`,
    `import type { UseQueryOptions, UseQueryResult } from "${useQueryPath}";`,
    `import { useStream as useStreamHook } from "${useStreamPath}";`,
    `import type { UseStreamOptions, UseStreamResult } from "${useStreamPath}";`,
    ""
  );

  // Add stream parser helper
  lines.push(
    "async function* parseResponseStream(res: Response, transform: (chunk: string) => any): AsyncGenerator<any> {",
    "  const reader = res.body?.getReader();",
    "  if (!reader) return;",
    "  const decoder = new TextDecoder();",
    "  while (true) {",
    "    const { done, value } = await reader.read();",
    "    if (done) break;",
    "    const chunk = decoder.decode(value, { stream: true });",
    "    yield* transform(chunk);",
    "  }",
    "}",
    "",
    "function* parseSSEChunk(chunk: string): Generator<any> {",
    '  const lines = chunk.split("\\n\\n");',
    "  for (const line of lines) {",
    '    if (line.startsWith("data: ")) {',
    "      try { yield JSON.parse(line.slice(6)); } catch {}",
    "    }",
    "  }",
    "}",
    "",
    "async function* parseSSE(res: Response): AsyncGenerator<any> {",
    "  return yield* parseResponseStream(res, parseSSEChunk);",
    "}",
    "",
    "async function* parseStream(res: Response): AsyncGenerator<any> {",
    "  return yield* parseResponseStream(res, function* (chunk) { yield chunk; });",
    "}",
    ""
  );

  // ClientResponse mapping type
  lines.push(
    "type ClientResponse<T> = T extends { __brand: 'streaming', __type: infer U }",
    "  ? AsyncIterable<U>",
    "  : T extends { __brand: 'sse', __type: infer U }",
    "  ? AsyncIterable<U>",
    "  : T;",
    ""
  );

  // Add request function
  lines.push(
    "async function request<TResponse, TParams = Record<string, unknown>, TQuery = Record<string, unknown>, TBody = unknown>(",
    "  method: string,",
    "  path: string,",
    "  opts?: { params?: TParams; query?: TQuery; body?: TBody; headers?: HeadersInit }",
    "): Promise<ClientResponse<TResponse>> {",
    "  let url = path;",
    "  if (opts?.params) {",
    "    for (const [k, v] of Object.entries(opts.params)) url = url.replace(`[${k}]`, String(v));",
    "  }",
    "  if (opts?.query) {",
    "    const p = new URLSearchParams();",
    "    for (const [k, v] of Object.entries(opts.query)) p.append(k, String(v));",
    "    url += `?${p}`;",
    "  }",
    '  if (url.startsWith("/") && typeof window === "undefined") {',
    `    url = \`http://\${process.env.BUNBOX_HOSTNAME || "${
      config?.hostname || "localhost"
    }"\ }:\${process.env.BUNBOX_PORT || "${config?.port || 3000}"}\${url}\`;`,
    "  }",
    "  const res = await fetch(url, {",
    "    method,",
    '    headers: { "Content-Type": "application/json", ...opts?.headers },',
    '    body: opts?.body && method !== "GET" ? JSON.stringify(opts.body) : undefined,',
    "  });",
    "  if (!res.ok) throw new Error(await res.text());",
    "  const contentType = res.headers.get('content-type') || '';",
    "  if (contentType.includes('text/event-stream')) {",
    "    return parseSSE(res) as any;",
    "  }",
    "  if (res.headers.has('X-Bunbox-Stream')) {",
    "    return parseStream(res) as any;",
    "  }",
    "  return res.json();",
    "}",
    ""
  );

  // Add helper to create API method with hooks - using flattened options
  lines.push(
    "// Flattened options type - params, query, and body all at top level",
    "// Exclude default Record<string, unknown> to avoid index signature conflicts",
    "type IsDefaultRecord<T> = T extends Record<string, unknown>",
    "  ? keyof T extends never ? true : string extends keyof T ? true : false",
    "  : false;",
    "type FlattenedOptions<TParams, TQuery, TBody> = ",
    "  & (IsDefaultRecord<TParams> extends true ? {} : TParams)",
    "  & (IsDefaultRecord<TQuery> extends true ? {} : TQuery)",
    "  & (IsDefaultRecord<TBody> extends true ? {} : TBody)",
    "  & { headers?: HeadersInit };",
    "",
    "type ApiMethod<TResponse, TParams, TQuery, TBody> = {",
    "  (opts?: FlattenedOptions<TParams, TQuery, TBody>): Promise<ClientResponse<TResponse>>;",
    "  useQuery: (opts?: FlattenedOptions<TParams, TQuery, TBody> & { enabled?: boolean }) => UseQueryResult<ClientResponse<TResponse>>;",
    "  useStream: (opts?: FlattenedOptions<TParams, TQuery, TBody> & { enabled?: boolean; onMessage?: (data: any) => void; onError?: (error: Error) => void; onFinish?: () => void }) => UseStreamResult<TResponse extends { __type: infer U } ? U : TResponse>;",
    "};",
    "",
    "function createApiMethod<TResponse, TParams = Record<string, unknown>, TQuery = Record<string, unknown>, TBody = unknown>(",
    "  method: string,",
    "  path: string,",
    "  paramKeys: string[]",
    "): ApiMethod<TResponse, TParams, TQuery, TBody> {",
    "  // Separate flattened options into params/query/body based on method and paramKeys",
    "  function separateOptions(opts?: Record<string, unknown>) {",
    "    if (!opts) return {};",
    "    const params: Record<string, unknown> = {};",
    "    const query: Record<string, unknown> = {};",
    "    const body: Record<string, unknown> = {};",
    "    const headers = opts.headers as HeadersInit | undefined;",
    "    const enabled = opts.enabled;",
    "    ",
    "    for (const [key, value] of Object.entries(opts)) {",
    "      if (key === 'headers' || key === 'enabled' || key === 'onMessage' || key === 'onError' || key === 'onFinish') continue;",
    "      if (paramKeys.includes(key)) {",
    "        params[key] = value;",
    "      } else if (method === 'GET' || method === 'DELETE') {",
    "        query[key] = value;",
    "      } else {",
    "        body[key] = value;",
    "      }",
    "    }",
    "    return { params, query, body, headers, enabled };",
    "  }",
    "  ",
    "  const fn = (opts?: FlattenedOptions<TParams, TQuery, TBody>) => {",
    "    const { params, query, body, headers } = separateOptions(opts as Record<string, unknown>);",
    "    return request<TResponse, TParams, TQuery, TBody>(method, path, { params: params as TParams, query: query as TQuery, body: body as TBody, headers });",
    "  };",
    "  fn.useQuery = (opts?: FlattenedOptions<TParams, TQuery, TBody> & { enabled?: boolean }) => {",
    "    const separated = separateOptions(opts as Record<string, unknown>);",
    "    return createQueryHook<ClientResponse<TResponse>>(method, path, { params: separated.params, query: separated.query, body: separated.body, headers: separated.headers, enabled: separated.enabled as boolean | undefined });",
    "  };",
    "  fn.useStream = (opts?: FlattenedOptions<TParams, TQuery, TBody> & { enabled?: boolean; onMessage?: (data: any) => void; onError?: (error: Error) => void; onFinish?: () => void }) => {",
    "    type ExtractedType = TResponse extends { __type: infer U } ? U : TResponse;",
    "    return useStreamHook<ExtractedType>(fn, opts);",
    "  };",
    "  return fn as ApiMethod<TResponse, TParams, TQuery, TBody>;",
    "}",
    ""
  );

  // Build API object
  lines.push("export const api = {");
  const apiLines = buildApiObject(routeTree, 1);
  if (apiLines.length > 0) {
    lines.push(...apiLines);
  }
  lines.push("};");

  return lines.join("\n");
}
